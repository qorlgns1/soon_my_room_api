name: CI/CD Pipeline for Soon My Room API

on:
  push:
    branches: [main, develop]

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.get_tag.outputs.tag }}
      branch_name: ${{ steps.get_branch.outputs.branch }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get branch name
        id: get_branch
        run: echo "branch=$(echo ${GITHUB_REF#refs/heads/})" >> $GITHUB_OUTPUT

      - name: Get Image Tag (Commit SHA)
        id: get_tag
        run: echo "tag=${{ steps.get_branch.outputs.branch }}-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Create Sentry release
        uses: getsentry/action-release@v3
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ secrets.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ secrets.SENTRY_PROJECT }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
        with:
          environment: ${{ steps.get_branch.outputs.branch == 'main' && 'production' || 'development' }}
          version: ${{ steps.get_tag.outputs.tag }}

      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: "21"
          distribution: "temurin"
          cache: "gradle"

      - name: Build with Gradle
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        run: ./gradlew build -x test

      - name: Apply Spotless
        run: ./gradlew spotlessApply

      - name: Clean Gradle Cache
        run: |
          rm -rf $HOME/.gradle/caches/
          ./gradlew clean --refresh-dependencies

      - name: Run tests
        env:
          # 테스트 시 H2 사용 위한 환경 변수 비우기
          DB_URL: ""
          DB_USERNAME: ""
          DB_PASSWORD: ""
        run: ./gradlew test

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Docker Hub 로그인 (Secrets 필요)
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      # Docker 이미지 빌드 및 푸시 (Secrets 필요)
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKER_HUB_USERNAME }}/soon-my-room-api:${{ steps.get_tag.outputs.tag }}
          build-args: |
            SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }}
            SERVER_PORT=${{ env.SERVER_PORT }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    # GitHub Environments 사용 (환경별 Secret 관리 용이)
    environment: ${{ needs.build.outputs.branch_name == 'main' && 'production' || 'development' }}
    steps:
      # 1. 환경 변수 설정 (브랜치 기반)
      - name: Set Environment Variables
        id: set_env
        run: |
          EC2_BASE_WORKSPACE_PATH="/home/ubuntu/workspace" # EC2 프로젝트 기본 경로
          if [[ "${{ needs.build.outputs.branch_name }}" == "main" ]]; then
            echo "EC2_HOST=${{ secrets.EC2_HOST }}" >> $GITHUB_ENV
            echo "EC2_USERNAME=${{ secrets.EC2_USERNAME }}" >> $GITHUB_ENV # ubuntu 사용자로 고정
            echo "EC2_SSH_KEY<<EOF" >> $GITHUB_ENV
            echo "${{ secrets.EC2_SSH_KEY }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "ENV_FILE_CONTENT<<EOF" >> $GITHUB_ENV
            echo "${{ secrets.PROD_ENV_FILE_CONTENT }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "ENV_FILE_NAME=.env.production.local" >> $GITHUB_ENV
            echo "APP_COMPOSE_FILE=docker-compose.prod.yml" >> $GITHUB_ENV # 앱 컴포즈 파일
            echo "NGINX_CONF_NAME=prod-soon-my-room.kihoonbae.store.conf" >> $GITHUB_ENV # Nginx 설정 파일
            echo "SERVICE_PREFIX=prod" >> $GITHUB_ENV
            echo "BLUE_PORT=9000" >> $GITHUB_ENV
            echo "GREEN_PORT=9001" >> $GITHUB_ENV
          else # develop branch
            echo "EC2_HOST=${{ secrets.EC2_HOST }}" >> $GITHUB_ENV
            echo "EC2_USERNAME=${{ secrets.EC2_USERNAME }}" >> $GITHUB_ENV
            echo "EC2_SSH_KEY<<EOF" >> $GITHUB_ENV
            echo "${{ secrets.EC2_SSH_KEY }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "ENV_FILE_CONTENT<<EOF" >> $GITHUB_ENV
            echo "${{ secrets.DEV_ENV_FILE_CONTENT }}" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "ENV_FILE_NAME=.env.development.local" >> $GITHUB_ENV
            echo "APP_COMPOSE_FILE=docker-compose.dev.yml" >> $GITHUB_ENV # 앱 컴포즈 파일
            echo "NGINX_CONF_NAME=dev-soon-my-room.kihoonbae.store.conf" >> $GITHUB_ENV # Nginx 설정 파일
            echo "SERVICE_PREFIX=dev" >> $GITHUB_ENV
            echo "BLUE_PORT=8000" >> $GITHUB_ENV
            echo "GREEN_PORT=8001" >> $GITHUB_ENV
          fi
          # 공통 변수
          echo "IMAGE_TAG=${{ needs.build.outputs.image_tag }}" >> $GITHUB_ENV
          echo "EC2_PROJECT_PATH=$EC2_BASE_WORKSPACE_PATH" >> $GITHUB_ENV # .env 복사 및 스크립트에서 사용
          echo "REVERSE_PROXY_PATH=$EC2_BASE_WORKSPACE_PATH/reverse-proxy" >> $GITHUB_ENV # 스크립트에서 사용
          echo "API_PROJECT_PATH=$EC2_BASE_WORKSPACE_PATH/soon_my_room_api" >> $GITHUB_ENV # .env 복사 시 사용
          echo "NGINX_COMPOSE_FILE=docker-compose.nginx.yml" >> $GITHUB_ENV # Nginx 컴포즈 파일 이름
          echo "NGINX_SERVICE_NAME=nginx-proxy" >> $GITHUB_ENV # 통합된 Nginx 서비스 이름
          echo "SHARED_NETWORK_NAME=soon-my-room-network" >> $GITHUB_ENV # 공유 네트워크 이름
          echo "HEALTH_CHECK_ENDPOINT=/swagger-ui/index.html" >> $GITHUB_ENV # 헬스 체크 경로
          echo "EC2_TEMP_STATUS_FILE=/tmp/deployment_status_${{ github.run_id }}.txt" >> $GITHUB_ENV

      # 2. .env 파일 로컬 생성
      - name: Create .env file locally
        run: echo "${{ env.ENV_FILE_CONTENT }}" > ${{ env.ENV_FILE_NAME }}

      # 3. .env 파일 EC2에 복사
      - name: Copy env file to EC2
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          source: "${{ env.ENV_FILE_NAME }}"
          target: "${{ env.API_PROJECT_PATH }}/"

      # 4. 공유 네트워크 및 Nginx 서비스 실행 보장
      - name: Ensure Shared Network and Nginx Service Running
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            REVERSE_PROXY_PATH="${{ env.REVERSE_PROXY_PATH }}"
            NGINX_COMPOSE_FILE="${{ env.NGINX_COMPOSE_FILE }}"

            cd $REVERSE_PROXY_PATH || { echo "Error: Failed to cd into $REVERSE_PROXY_PATH" >&2; exit 1; }

            echo "--- Ensuring Nginx and Network ---"
            # docker-compose 명령어 확인
            if ! command -v docker-compose &> /dev/null; then
                echo "Error: docker-compose command not found." >&2
                exit 1
            fi
            # Nginx 컴포즈 파일 확인
            if [ ! -f "$NGINX_COMPOSE_FILE" ]; then
                echo "Error: Nginx compose file '$NGINX_COMPOSE_FILE' not found in $REVERSE_PROXY_PATH" >&2
                exit 1
            fi

            # 네트워크와 Nginx 컨테이너 실행/생성 (멱등성 보장)
            if ! docker-compose -f $NGINX_COMPOSE_FILE up -d --remove-orphans; then
              echo "Error: Failed to start Nginx service using $NGINX_COMPOSE_FILE" >&2
              exit 1
            fi
            echo "Nginx service and network are up."
            echo "---------------------------------"

      # 5. 현재 배포 상태 확인 및 Target 결정 (결과를 EC2 임시 파일에 저장)
      - name: Check Deployment Status and Write to Temp File
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            # 환경 변수 설정
            NGINX_CONF_PATH="${{ env.REVERSE_PROXY_PATH }}/nginx/conf.d/${{ env.NGINX_CONF_NAME }}"
            SERVICE_PREFIX="${{ env.SERVICE_PREFIX }}"
            BLUE_SERVICE="${SERVICE_PREFIX}-app-blue"
            GREEN_SERVICE="${SERVICE_PREFIX}-app-green"
            BLUE_PORT=${{ env.BLUE_PORT }}
            GREEN_PORT=${{ env.GREEN_PORT }}
            APP_COMPOSE_FILE="${{ env.APP_COMPOSE_FILE }}"
            REVERSE_PROXY_PATH="${{ env.REVERSE_PROXY_PATH }}"
            # 임시 파일 경로 사용
            TEMP_STATUS_FILE="${{ env.EC2_TEMP_STATUS_FILE }}"

            echo "--- Checking Deployment Status ---"
            echo "Checking Nginx Conf: $NGINX_CONF_PATH"
            echo "Using App Compose File: $APP_COMPOSE_FILE"

            cd $REVERSE_PROXY_PATH || { echo "Error: Failed to cd into $REVERSE_PROXY_PATH" >&2; exit 1; }

            # 기본값 설정
            CURRENT_SERVICE="none"
            CURRENT_PORT="none"
            TARGET_SERVICE=$BLUE_SERVICE
            TARGET_PORT=$BLUE_PORT

            # 앱 컴포즈 파일 확인
            if [ ! -f "$APP_COMPOSE_FILE" ]; then
                echo "Error: Application compose file '$APP_COMPOSE_FILE' not found." >&2
                exit 1
            fi

            # 현재 실행 중인 앱 컨테이너 ID 확인
            RUNNING_BLUE_ID=$(docker-compose -f $APP_COMPOSE_FILE ps -q $BLUE_SERVICE 2>/dev/null || echo "")
            RUNNING_GREEN_ID=$(docker-compose -f $APP_COMPOSE_FILE ps -q $GREEN_SERVICE 2>/dev/null || echo "")
            echo "Running Blue App Container ID: '$RUNNING_BLUE_ID'"
            echo "Running Green App Container ID: '$RUNNING_GREEN_ID'"

            # Nginx 설정 파일 확인 및 상태 판별
            if [ -f "$NGINX_CONF_PATH" ]; then
                echo "Nginx config file found."
                # Green을 가리키고 Green 컨테이너가 실행 중이면 Green이 현재 활성
                if grep -q "proxy_pass http://${GREEN_SERVICE}:${GREEN_PORT}" "$NGINX_CONF_PATH" && [ ! -z "$RUNNING_GREEN_ID" ]; then
                    echo "Status: Active service is GREEN."
                    CURRENT_SERVICE=$GREEN_SERVICE
                    CURRENT_PORT=$GREEN_PORT
                    TARGET_SERVICE=$BLUE_SERVICE
                    TARGET_PORT=$BLUE_PORT
                # Blue를 가리키고 Blue 컨테이너가 실행 중이면 Blue가 현재 활성
                elif grep -q "proxy_pass http://${BLUE_SERVICE}:${BLUE_PORT}" "$NGINX_CONF_PATH" && [ ! -z "$RUNNING_BLUE_ID" ]; then
                    echo "Status: Active service is BLUE."
                    CURRENT_SERVICE=$BLUE_SERVICE
                    CURRENT_PORT=$BLUE_PORT
                    TARGET_SERVICE=$GREEN_SERVICE
                    TARGET_PORT=$GREEN_PORT
                else
                    echo "Warning: Cannot reliably determine active service from Nginx config and running containers. Defaulting to target BLUE." >&2
                fi
            else
                echo "Info: Nginx config file not found. Assuming initial deployment. Targeting BLUE."
            fi

            echo "--- Determined Status ---"
            echo "Current Service: $CURRENT_SERVICE (Port: $CURRENT_PORT)"
            echo "Target Service: $TARGET_SERVICE (Port: $TARGET_PORT)"
            echo "-------------------------"

            echo "Writing status to $TEMP_STATUS_FILE on EC2..."
            {
              echo "CURRENT_SERVICE=$CURRENT_SERVICE"
              echo "TARGET_SERVICE=$TARGET_SERVICE"
              echo "CURRENT_PORT=$CURRENT_PORT"
              echo "TARGET_PORT=$TARGET_PORT"
            } > "$TEMP_STATUS_FILE"
            echo "Status file created."

      # 6. EC2 로그인, 새 버전 앱 배포 (통합 스텝)
      - name: Login EC2, Deploy New Application Version
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            # --- 1. 로그인 ---
            echo "Logging into Docker Hub on EC2..."
            if ! docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} --password-stdin <<< "${{ secrets.DOCKER_HUB_TOKEN }}"; then
              echo "Error: Docker login failed on EC2." >&2
              exit 1
            fi
            echo "Docker login successful on EC2."

            # --- 2. 배포 로직 (기존 Deploy 스텝 스크립트 내용) ---
            REVERSE_PROXY_PATH="${{ env.REVERSE_PROXY_PATH }}"
            APP_COMPOSE_FILE="${{ env.APP_COMPOSE_FILE }}"
            export IMAGE_TAG="${{ env.IMAGE_TAG }}"
            TEMP_STATUS_FILE="${{ env.EC2_TEMP_STATUS_FILE }}"

            # 임시 파일 로드
            if [[ -f "$TEMP_STATUS_FILE" ]]; then source "$TEMP_STATUS_FILE"; else echo "Error: Status file $TEMP_STATUS_FILE not found!" >&2; exit 1; fi
            if [ -z "$TARGET_SERVICE" ]; then echo "Error: TARGET_SERVICE is empty after loading!" >&2; exit 1; fi

            cd $REVERSE_PROXY_PATH || { echo "Error: Failed to cd into $REVERSE_PROXY_PATH" >&2; exit 1; }

            echo "--- Deploying New Application Version ---"
            echo "Target Service: $TARGET_SERVICE"
            echo "Image Tag: $IMAGE_TAG"

            echo "Pulling new image for $TARGET_SERVICE..."
            # 이제 로그인이 된 상태이므로 성공해야 함
            if ! docker-compose -f $APP_COMPOSE_FILE pull $TARGET_SERVICE; then echo "Error: Failed to pull image for $TARGET_SERVICE" >&2; exit 1; fi
            echo "Image pull successful."

            echo "Starting new container for $TARGET_SERVICE..."
            if ! docker-compose -f $APP_COMPOSE_FILE up -d --no-deps --force-recreate $TARGET_SERVICE; then echo "Error: Failed to start container for $TARGET_SERVICE" >&2; exit 1; fi
            echo "Container deployment initiated."
            echo "---------------------------------------"

      # 7. 새 버전 앱 배포 (EC2 임시 파일 직접 참조)
      - name: Deploy New Application Version
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            REVERSE_PROXY_PATH="${{ env.REVERSE_PROXY_PATH }}"
            APP_COMPOSE_FILE="${{ env.APP_COMPOSE_FILE }}"
            export IMAGE_TAG="${{ env.IMAGE_TAG }}"
            # EC2 임시 파일 경로 사용
            TEMP_STATUS_FILE="${{ env.EC2_TEMP_STATUS_FILE }}"

            # --- 임시 파일 로드 ---
            if [[ -f "$TEMP_STATUS_FILE" ]]; then
              echo "Loading status from $TEMP_STATUS_FILE..."
              # source 명령어는 KEY=VALUE 형태의 파일을 읽어 현재 쉘에 변수로 설정함
              source "$TEMP_STATUS_FILE"
            else
              echo "Error: Status file $TEMP_STATUS_FILE not found!" >&2
              # 기본값 설정 또는 에러 처리
              TARGET_SERVICE="${{ env.SERVICE_PREFIX }}-app-blue" # Default
              echo "Warning: Using default TARGET_SERVICE=$TARGET_SERVICE" >&2
              # exit 1 # 필요시 실패 처리
            fi
            # --- 이제 $TARGET_SERVICE 등의 변수 사용 가능 ---

            if [ -z "$TARGET_SERVICE" ]; then echo "Error: TARGET_SERVICE is empty after loading!" >&2; exit 1; fi

            cd $REVERSE_PROXY_PATH || { echo "Error: Failed to cd into $REVERSE_PROXY_PATH" >&2; exit 1; }

            echo "--- Deploying New Application Version ---"
            echo "Target Service: $TARGET_SERVICE"
            echo "Image Tag: $IMAGE_TAG"
            echo "Using Compose File: $APP_COMPOSE_FILE"

            echo "Pulling new image for $TARGET_SERVICE..."
            if ! docker-compose -f $APP_COMPOSE_FILE pull $TARGET_SERVICE; then
              echo "Error: Failed to pull image for $TARGET_SERVICE" >&2
              exit 1
            fi
            echo "Image pull successful."

            echo "Starting new container for $TARGET_SERVICE..."
            # --force-recreate: 기존 컨테이너 강제 재생성
            if ! docker-compose -f $APP_COMPOSE_FILE up -d --no-deps --force-recreate $TARGET_SERVICE; then
              echo "Error: Failed to start container for $TARGET_SERVICE" >&2
              exit 1
            fi
            echo "Container deployment initiated for $TARGET_SERVICE."
            echo "---------------------------------------"

      # 8. 헬스 체크 (EC2 임시 파일 직접 참조)
      - name: Health Check New Application Version
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            HEALTH_ENDPOINT="${{ env.HEALTH_CHECK_ENDPOINT }}"
            MAX_ATTEMPTS=30
            SLEEP_SECONDS=2
            REVERSE_PROXY_PATH="${{ env.REVERSE_PROXY_PATH }}"
            APP_COMPOSE_FILE="${{ env.APP_COMPOSE_FILE }}"
            TEMP_STATUS_FILE="${{ env.EC2_TEMP_STATUS_FILE }}"

            # --- 임시 파일 로드 ---
            if [[ -f "$TEMP_STATUS_FILE" ]]; then
              echo "Loading status from $TEMP_STATUS_FILE..."
              source "$TEMP_STATUS_FILE"
            else
              echo "Error: Status file $TEMP_STATUS_FILE not found!" >&2
              TARGET_PORT="${{ env.BLUE_PORT }}" # Default
              TARGET_SERVICE="${{ env.SERVICE_PREFIX }}-app-blue" # Default
              echo "Warning: Using default TARGET_PORT=$TARGET_PORT, TARGET_SERVICE=$TARGET_SERVICE" >&2
              # exit 1
            fi
            # --- 이제 $TARGET_PORT, $TARGET_SERVICE 사용 가능 ---

            if [ -z "$TARGET_PORT" ]; then echo "Error: TARGET_PORT is empty after loading!" >&2; exit 1; fi
            if [ -z "$TARGET_SERVICE" ]; then echo "Error: TARGET_SERVICE is empty after loading!" >&2; exit 1; fi


            echo "--- Performing Health Check ---"
            echo "Checking endpoint: http://localhost:$TARGET_PORT$HEALTH_ENDPOINT"

            for i in $(seq 1 $MAX_ATTEMPTS); do
              HTTP_CODE=$(curl --connect-timeout 5 --fail -s -o /dev/null -w "%{http_code}" http://localhost:$TARGET_PORT$HEALTH_ENDPOINT)
              EXIT_CODE=$?

              if [ $EXIT_CODE -eq 0 ]; then
                echo "Attempt $i: Health check successful! (HTTP Status: $HTTP_CODE)"
                echo "-----------------------------"
                # 성공
                exit 0 
              fi
              echo "Attempt $i: Health check failed (curl exit code: $EXIT_CODE). Retrying in $SLEEP_SECONDS seconds..."
              sleep $SLEEP_SECONDS
            done

            echo "Error: Health check failed after $MAX_ATTEMPTS attempts." >&2
            # 실패 시 새로 띄운 앱 컨테이너 중지
            echo "Stopping failed container $TARGET_SERVICE..."
            cd $REVERSE_PROXY_PATH && docker-compose -f $APP_COMPOSE_FILE stop $TARGET_SERVICE
                        echo "-----------------------------"
            # 실패
            exit 1

      # 9. Nginx 트래픽 전환 및 이전 버전 중지 (EC2 임시 파일 직접 참조 및 삭제)
      - name: Switch Nginx and Stop Old Container
        # 헬스 체크 성공 시에만 실행
        if: success()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            # 환경 변수 사용
            NGINX_CONF_PATH="${{ env.REVERSE_PROXY_PATH }}/nginx/conf.d/${{ env.NGINX_CONF_NAME }}"
            NGINX_SERVICE=${{ env.NGINX_SERVICE_NAME }}
            NGINX_COMPOSE_FILE=${{ env.NGINX_COMPOSE_FILE }}
            APP_COMPOSE_FILE=${{ env.APP_COMPOSE_FILE }}
            REVERSE_PROXY_PATH="${{ env.REVERSE_PROXY_PATH }}"
            SERVICE_PREFIX="${{ env.SERVICE_PREFIX }}"
            DEFAULT_BLUE_SERVICE="${SERVICE_PREFIX}-app-blue"
            DEFAULT_BLUE_PORT=${{ env.BLUE_PORT }}
            TEMP_STATUS_FILE="${{ env.EC2_TEMP_STATUS_FILE }}"

            # --- 임시 파일 로드 ---
            if [[ -f "$TEMP_STATUS_FILE" ]]; then
              echo "Loading status from $TEMP_STATUS_FILE..."
              source "$TEMP_STATUS_FILE"
            else
              echo "Error: Status file $TEMP_STATUS_FILE not found!" >&2
              # 기본값 설정 또는 에러 처리 (이 스텝까지 왔다면 파일이 있어야 정상)
              exit 1
            fi
            # --- 이제 $CURRENT_SERVICE, $TARGET_SERVICE, $CURRENT_PORT, $TARGET_PORT 사용 가능 ---

            # 필수 변수 확인
            if [ -z "$TARGET_SERVICE" ] || [ -z "$TARGET_PORT" ]; then echo "Error: TARGET_SERVICE or TARGET_PORT is empty!" >&2; exit 1; fi
            # CURRENT_SERVICE와 CURRENT_PORT는 'none'일 수 있음

            cd $REVERSE_PROXY_PATH || { echo "Error: Failed to cd into $REVERSE_PROXY_PATH" >&2; exit 1; }

            echo "--- Switching Nginx Traffic ---"
            echo "Target Service: $TARGET_SERVICE (Port: $TARGET_PORT)"

            # Nginx 설정 파일 존재 확인
            if [ ! -f "$NGINX_CONF_PATH" ]; then
              echo "Error: Nginx config file $NGINX_CONF_PATH not found!" >&2
              # 필요하다면 여기서 기본 설정 파일 생성 로직 추가 가능
              exit 1
            fi

            # 설정 변경 전 백업
            BACKUP_PATH="${NGINX_CONF_PATH}.backup.$(date +%s)"
            echo "Backing up Nginx config to $BACKUP_PATH"
            sudo cp "$NGINX_CONF_PATH" "$BACKUP_PATH"

            # proxy_pass 변경 (sed 패턴 주의!)
            TARGET_PROXY_PASS="proxy_pass http://${TARGET_SERVICE}:${TARGET_PORT}"
            if [ "$CURRENT_SERVICE" != "none" ]; then
                echo "Updating Nginx: $CURRENT_SERVICE:$CURRENT_PORT -> $TARGET_SERVICE:$TARGET_PORT"
                # CURRENT_PORT 값이 'none'이 아닐 때만 CURRENT_PROXY_PASS 설정
                if [ "$CURRENT_PORT" != "none" ]; then
                  CURRENT_PROXY_PASS="proxy_pass http://${CURRENT_SERVICE}:${CURRENT_PORT}"
                  if ! sudo sed -i "s#${CURRENT_PROXY_PASS}#${TARGET_PROXY_PASS}#g" "$NGINX_CONF_PATH"; then echo "Error(1): Failed to update proxy_pass using sed." >&2; sudo mv "$BACKUP_PATH" "$NGINX_CONF_PATH"; exit 1; fi
                else
                   echo "Warning: CURRENT_SERVICE is set but CURRENT_PORT is 'none'. Cannot reliably replace proxy_pass." >&2
                   # 이 경우 어떻게 처리할지 정책 필요 (예: 기본 Blue 기준으로 변경 시도 또는 실패 처리)
                   # 여기서는 기본 Blue 기준으로 변경 시도
                   DEFAULT_PROXY_PASS="proxy_pass http://${DEFAULT_BLUE_SERVICE}:${DEFAULT_BLUE_PORT}"
                   if ! sudo sed -i "s#${DEFAULT_PROXY_PASS}#${TARGET_PROXY_PASS}#g" "$NGINX_CONF_PATH"; then echo "Error(2): Failed to update proxy_pass using sed." >&2; sudo mv "$BACKUP_PATH" "$NGINX_CONF_PATH"; exit 1; fi
                fi
            else
                echo "Initial deployment: Updating default Nginx config to point to $TARGET_SERVICE:$TARGET_PORT"
                DEFAULT_PROXY_PASS="proxy_pass http://${DEFAULT_BLUE_SERVICE}:${DEFAULT_BLUE_PORT}"
                if ! sudo sed -i "s#${DEFAULT_PROXY_PASS}#${TARGET_PROXY_PASS}#g" "$NGINX_CONF_PATH"; then echo "Error(3): Failed to update default proxy_pass using sed." >&2; sudo mv "$BACKUP_PATH" "$NGINX_CONF_PATH"; exit 1; fi
            fi
            echo "Nginx config file updated."

            echo "Testing Nginx configuration..."
            if docker-compose -f "$NGINX_COMPOSE_FILE" exec -T "$NGINX_SERVICE" nginx -t; then # 따옴표 추가
              echo "Nginx configuration test successful. Reloading Nginx..."
              if ! docker-compose -f "$NGINX_COMPOSE_FILE" exec -T "$NGINX_SERVICE" nginx -s reload; then echo "Error: Failed to reload Nginx." >&2; echo "Rolling back Nginx configuration..."; sudo mv "$BACKUP_PATH" "$NGINX_CONF_PATH"; exit 1; fi
              echo "Nginx reloaded successfully."

              # 이전 버전 앱 컨테이너 중지
              if [ "$CURRENT_SERVICE" != "none" ]; then
                echo "Stopping old container $CURRENT_SERVICE after 30 seconds delay..."
                sleep 30
                if ! docker-compose -f "$APP_COMPOSE_FILE" stop "$CURRENT_SERVICE"; then echo "Warning: Failed to stop old container $CURRENT_SERVICE." >&2; else echo "Old container $CURRENT_SERVICE stopped."; fi
              else
                echo "Initial deployment completed. No old container to stop."
              fi
              echo "-----------------------------"
            else
              echo "Error: Nginx configuration test failed!" >&2
              echo "Rolling back Nginx configuration..."
              sudo mv "$BACKUP_PATH" "$NGINX_CONF_PATH"
              echo "Nginx configuration restored."
              echo "Stopping and removing failed target container $TARGET_SERVICE..."
              docker-compose -f "$APP_COMPOSE_FILE" stop "$TARGET_SERVICE"
              docker-compose -f "$APP_COMPOSE_FILE" rm -f "$TARGET_SERVICE"
              echo "-----------------------------"
              exit 1
            fi

            # --- 임시 파일 삭제 ---
            echo "Cleaning up temporary status file: $TEMP_STATUS_FILE"
            rm -f "$TEMP_STATUS_FILE"
            echo "Temporary file removed."

      # 10. 오래된 Docker 이미지 정리
      - name: Clean Up Old Docker Images
        if: always()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.EC2_HOST }}
          username: ${{ env.EC2_USERNAME }}
          key: ${{ env.EC2_SSH_KEY }}
          script: |
            echo "--- Cleaning up old docker images ---"
            docker image prune -af --filter "until=168h"
            echo "-----------------------------------"
